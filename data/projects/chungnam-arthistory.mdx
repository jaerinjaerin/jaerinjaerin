---
slug: chungnam-arthistory
title: 충남미술사 아카이브
description: 인터랙티브 지도와 타임라인으로 시각화한 플랫폼
thumbnail: /projects/chungnam-arthistory/1.png
tags:
  - Next.js 15 (App Router)
  - TypeScript
  - Tailwind CSS
  - Mapbox GL
  - Zustand
period:
  start: '2025.10'
  end: '2025.12'
featured: true
order: 1
role: Frontend Developer
team:
  size: 2인(프론트엔드 1인, 기획 1인)
overview: 충남미술관에서 진행한 개화기(1876년)부터 1990년대까지의 충남 미술사 자료를 디지털화한 아카이브 플랫폼입니다. 미술단체, 교육기관, 전시공간, 인물 등 4가지 카테고리로 분류된 데이터를 시기별·지역별로 필터링하여 탐색할 수 있으며, 지도 위에 마커로 시각화하여 지리적 맥락에서 충남 미술사의 흐름을 파악할 수 있습니다.
problem: 인터랙션이 많은 프로젝트로 클릭 시 지도가 확대, 축소되는 애니메이션이 끊기지 않고 자연스럽게 만들 방법이 필요했습니다.
solution: Mapbox GL을 이용해 지도 flyTo 이벤트와 좌표 값에 맞는 마커 렌더링을 구현하고 GeoJSON 데이터를 이용하여 충청남도의 지역을 시각적으로 구분하였습니다.
results:
  - 충청남도 미술 역사를 연도별, 지역별로 볼 수 있으며, 지도 이동 애니메이션을 통해 몰입감 있는 경험을 제공
  - 동일 좌표에 마커가 겹치는 문제를 Mapbox GL 클러스터링과 팝업 리스트로 해결, 100개 이상의 데이터를 지도에서 자연스럽게 탐색 가능

links:
  demo: https://chungnam-art-history.vercel.app/
images:
  - /projects/chungnam-arthistory/2.gif
  - /projects/chungnam-arthistory/1.png
  - /projects/chungnam-arthistory/3.png
---

## 🎯 프로젝트 상세

![image.png](/projects/chungnam-arthistory/8.png)

### 1. 실시간 지도 데이터 필터링을 위해 양방향 참조 데이터를 기반으로 O(1) 조회 최적화

- **필터링 이후 마커 렌더링 시퀀스 다이어그램**
  ![image.png](/projects/chungnam-arthistory/5.png)
- **문제 원인**
  - 연도/시기/카테고리 다중 필터 조건에서 매번 전체 데이터를 순회하며 해당 시기에 속하는 항목 필터링 과정 반복
  - 단일 useMemo로 전체 필터링 시, 하위 필터 변경에도 상위필터 재계산 발생
  - 단방향 참조 구조로 역방향 탐색 시 전체 데이터 순회 필요
- **해결 과정**

  - **향후 아카이브 자료가 지속적으로 누적될 것을 고려하여**, 데이터 양에 영향을 받지 않는 양방향 참조 구조 설계 **(확장성 고려)**

    ```tsx
    Period ──relation──▶ [person-001, person-002, ...]
                              │
                              ▼
    Person ──relation──▶ [period-001, period-003, ...]

    - Period → 하위 데이터: period.relation.people, period.relation.organizations 등
    - 하위 데이터 → Period: person.relation.periods, organization.relation.periods 등
    ```

  - 앱 초기화 시 periodDataMap, regionDataMap을 사전 계산하여 Lazy Caching

    ```tsx
    // 1. ID → 객체 Map (O(1) 조회)
    const dataMap = {
      organizations: new Map<string, Organization>(),
      people: new Map<string, Person>(),
      // ...
    };

    // 2. Period ID → 필터링된 데이터 Map (O(1) 조회)
    const periodDataMap = new Map<string, FilteredData>(
      periods.map((period) => [
        period.id,
        {
          organizations: mapIdsToData(period.relation.organizations, dataMap.organizations),
          people: mapIdsToData(period.relation.people, dataMap.people),
          // ...
        },
      ])
    );
    ```

  - useMemo로 의존성 분리하여 불필요한 재계산 방지

    ```tsx
    // 1단계: Period + Region (무거운 연산)
    const dataBeforeCategoryFilter = useMemo(() => {...},
      [selectedPeriod, selectedRegion]
    );

    // 2단계: Category + Role + ArtField (가벼운 연산)
    const activeData = useMemo(() => {...},
      [dataBeforeCategoryFilter, selectedCategory, selectedPersonRole, selectedArtField]
    );

    // - Period/Region 변경 시에만 1단계 재계산
    // - Category만 변경되면 2단계만 재계산
    ```

- **결과**
  - Period/Region 조회 O(n) → O(1) 개선
  - Category 변경 시 상위 필터 재계산 방지 (부분 캐싱)
  - 필터 조건 변경에 따른 마커 렌더링 지연 최소화

### 2. viewport **감지 커스텀 훅**으로 padding offset을 동적 계산하여 **flyTo 애니메이션**에 적용

- **마커가 중앙을 기준으로 확대될 때 문제 발생**
  ![image.png](/projects/chungnam-arthistory/6.png)
- **문제 원인**
  - 지도와 마커는 항상 화면의 중앙을 기준으로 렌더링됨
  - Mapbox는 기본적으로 화면 중앙을 기준으로 지도를 렌더링하기 때문에, 드로어가 차지하는 영역을 고려하지 못함
  - 드로어 너비가 viewport에 따라 반응형으로 변하기 때문에, 고정값이 아닌 동적 오프셋 계산 필요
- **해결 과정**

  - viewport 구간별 드로어 너비를 사전 정의
    ![image.png](/projects/chungnam-arthistory/7.png)
  - viewport 감지 후 해당 너비만큼 Mapbox padding offset 적용

    ```tsx
    if (focusItemPosition && mapRef.current && isMapLoaded) {
      // 1. 지역 bounds flyTo 비활성화
      setEnableRegionFlyTo(false);

      // 2. 해당 위치로 flyTo (drawer 오프셋 고려)
      mapRef.current.flyTo({
        center: [focusItemPosition.lng, focusItemPosition.lat],
        zoom: focusItemPosition.zoom || 14,
        duration: 1500,
        essential: true,
        padding: { right: drawerOffset, top: 0, bottom: 0, left: 0 },
      });
      // ...
    }
    ```

- **결과**
  - 드로어 오픈 여부에 관계없이 선택한 마커가 항상 가시 영역 중앙에 위치하여, 지도 재조작 없이 원하는 정보에 즉시 접근할 수 있는 UX를 구현

### 🚀 결과 / 기여

- 고빈도 인터랙션 환경에서 프레임 드랍 없는 부드러운 UI를 구현하여 일관된 사용자 경험을 보장하고자 했습니다.
- 학술 연구 자료를 일반인도 쉽게 탐색할 수 있도록 시각화하였습니다.
- 지리적 맥락에서 미술사의 흐름을 파악할 수 있는 UX를 설계했습니다.

### 💡 주요 구현 사항

1. 인터랙티브 지도 시스템
   - Mapbox GL 기반 충남 지도 구현
   - GeoJSON 역마스크 처리로 지역 외부 시각적 구분
   - 마우스 호버/클릭 시 지역 하이라이트 및 상호작용
   - 동일 좌표 마커 그룹화 및 팝업 표시
2. 타임라인 슬라이더
   - 드래그 기반 시기 선택 인터페이스
   - 근접 시기로 자동 스냅되는 부드러운 애니메이션
   - requestAnimationFrame을 활용하여 60fps 유지
3. 계층형 필터링 시스템
   - 시기 → 지역 → 카테고리 → 역할/미술분야 다단계 필터 구현
   - Map 자료구조 기반 O(1) 데이터 조회
   - useMemo를 통한 필터 결과 캐싱
4. [성능 최적화 ↗](https://jaerinjaerin.github.io/blog/optimize-our-website-and-improve-our-performance)
   - Zustand 선택적 구독으로 불필요한 리렌더링 방지
   - 드래그/애니메이션 중 마커 렌더링을 스킵하여 일관된 사용자 경험 제공
   - 동적 import로 Mapbox 클라이언트 사이드 로딩
   - DataMaps Singleton Caching (초기화 1회, 이후 O(1) 접근)
5. 통합 검색 기능
   - 전체 카테고리 대상 실시간 검색
   - 300ms 디바운싱으로 입력 최적화
   - 검색 결과 클릭 시 지도 포커스 이동
6. 반응형 드로어 UI
   - 목록/상세 정보 슬라이드 드로어
   - 반응형 동적 너비 계산
   - 이미지 갤러리 컴포넌트 구현 (확대/스와이프 지원)

### 🎓 배운 점 (Lessons Learned)

1. **데이터 구조가 성능을 결정한다**: 단방향 참조에서 양방향 참조로 전환하며 조회 복잡도를 O(n)에서 O(1)로 개선했습니다. 초기 설계 단계에서 확장성을 고려한 구조 설계가 이후 성능 최적화 비용을 줄인다는 것을 체감했습니다.

2. **부드러운 애니메이션이 몰입감을 만든다**: 지도 인터랙션에서 프레임 드랍이 발생하면 탐색 흐름이 끊어지지만, 60fps를 유지하면 사용자가 콘텐츠에 자연스럽게 집중합니다. 기술적 성능 지표가 실제 사용자 경험에 직접적으로 연결된다는 것을 확인했습니다.

3. **라이브러리의 기본 동작 원리를 파악해야 한다**: Mapbox의 화면 중앙 기준 렌더링 방식을 이해한 후에야 드로어와 지도가 겹치는 문제를 해결할 수 있었습니다. 공식 문서뿐 아니라 내부 동작 원리를 파악하는 것이 커스터마이징의 시작점임을 배웠습니다.
